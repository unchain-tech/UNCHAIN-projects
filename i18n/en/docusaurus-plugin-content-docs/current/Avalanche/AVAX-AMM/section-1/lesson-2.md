---
title: Creating Smart Contract with Solidity
---
From this point onward in section 1, we will be working with files inside the `AVAX-AMM/packages/contract` directory. üôå

### üë©‚Äçüíª Review of What We'll Implement

We will build a smart contract implementing AMM functionality.

Users will be able to use our smart contract to swap tokens.

Specifically, if our smart contract supports swapping between USDC and JOE tokens,
users can connect to the smart contract and exchange USDC for JOE tokensÔºàor JOE for USDCÔºâ.

Here are the three key terms essential for implementing an AMM:

üê¶ Pool

A pool refers to a collection of tokens available for swapping within a smart contract.

If the smart contract contains a USDC and JOE pool, users will be able to trade between USDC and JOE.

ü¶í Liquidity Provision

A market with a low amount of tokens in the poolÔºài.e., large price fluctuations during tradesÔºâis said to have low liquidity.
Conversely, when there‚Äôs a large amount of tokensÔºài.e., smaller price fluctuationsÔºâ, the market is said to have high liquidity.

Many AMMs include a mechanism where token holders can deposit their tokens into the pool to improve liquidity‚Äîthis is called liquidity provision.

For example, if there‚Äôs a USDC and JOE pool, people who own USDC and JOE tokens can deposit both into the pool.
ÔºàDepending on the DEX, you may or may not be required to provide both tokens.Ôºâ

Liquidity providers are often rewarded.
In this project, we will implement rewards by collecting a fee during swaps and distributing it to liquidity providers.

ü¶ç Swap

Refers to the action of exchanging one token for another.

---

Let‚Äôs summarize the features we will implement in this project:

1. Token holders can provide liquidity.
2. Users who have provided liquidity can withdraw their deposited tokens.
3. Users can swap tokens.
4. A fee is charged during swaps.
5. The fee generated by swaps is distributed to liquidity providers.

### ü•Æ Create the Contracts

We will create three contracts.

One `AMM contract`, which is the main smart contract of this project, and two `ERC20Token contracts` to simulate the AMM contract behavior.

While it is possible to use already existing tokens on `Fuji C-Chain` with the `AMM contract`,
having our own deployable `ERC20` contracts makes token acquisition more flexible and simpler.

Create two files under the `contracts` directory: `ERC20Tokens.sol` and `AMM.sol`.

When using Hardhat, file structure is very important, so please be careful.
If your structure looks like this, you‚Äôre good to go üòä

```
contract
‚îî‚îÄ‚îÄ contracts
    ‚îú‚îÄ‚îÄ AMM.sol
    ‚îî‚îÄ‚îÄ ERC20Tokens.sol
```

Now open the project in your code editor.

Paste the following code into `ERC20Tokens.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract USDCToken is ERC20 {
    constructor() ERC20("USDC Token", "USDC") {
        _mint(msg.sender, 10000 ether);
    }

    function faucet(address recipient, uint256 amount) external {
        _mint(recipient, amount);
    }
}

contract JOEToken is ERC20 {
    constructor() ERC20("JOE Token", "JOE") {
        _mint(msg.sender, 10000 ether);
    }

    function faucet(address recipient, uint256 amount) external {
        _mint(recipient, amount);
    }
}
```

Make sure `0.8.17` matches the version specified in `hardhat.config.ts`.

If the Solidity version in `hardhat.config.ts` is different from `0.8.17`, change the version in `ERC20Tokens.sol` to match it.

We are creating two `ERC20Token contracts` here:

`USDCToken` and `JOEToken`.

Let‚Äôs take a closer look at `USDCToken`.

```solidity
contract USDCToken is ERC20 {
    constructor() ERC20("USDC Token", "USDC") {
        _mint(msg.sender, 10000 ether);
    }

    function faucet(address recipient, uint256 amount) external {
        _mint(recipient, amount);
    }
}
```

The `USDCToken` contract inherits from `ERC20`, so it implements the functions of the `ERC20` standard.

[ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) is a token standard.

In the constructor of `USDCToken`, we call the constructor of `ERC20` with parameters to set the token name and symbol.

Within the constructor, `10000 ether (= 10000 x 10^18)` worth of `USDC` is minted to the deploying account.
‚Äª We will treat `USDC` and `JOE` in the same smallest unit as ether.

The `_mint` function is implemented in [ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).
Internally, it adds the specified token amount to both the total token supply and the balance of the specified account.

The `faucet` function is also implemented in `USDCToken`, which simply calls `_mint`.

This is designed to easily mint tokens to any address.

Next, paste the following code into `AMM.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract AMM {
    IERC20 private _tokenX; // ERC20-compliant contract
    IERC20 private _tokenY; // ERC20-compliant contract
    uint256 public totalShare; // Total share
    mapping(address => uint256) public share; // Share per user
    mapping(IERC20 => uint256) public totalAmount; // Amount of each token locked in pool

    uint256 public constant PRECISION = 1_000_000; // Precision constant for shares (= 6 digits)

    // Specify tokens usable in the pool
    constructor(IERC20 tokenX, IERC20 tokenY) {
        _tokenX = tokenX;
        _tokenY = tokenY;
    }
}
```

At the top of the file, we import `IERC20.sol` from `openzeppelin/contracts` to use `IERC20`.

In the implementation of the `AMM contract`, two objects of type `IERC20` are maintained:

```solidity
contract AMM {
    IERC20 private _tokenX; // ERC20-compliant contract
    IERC20 private _tokenY; // ERC20-compliant contract
    ...
}
```

These two objects represent the contract addresses for the token pair that our AMM will manage.
In this project, we‚Äôll pass the addresses of `USDCToken` and `JOEToken` to operate the AMM.

[IERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) is the interface of `ERC20`,
meaning it only defines the function signaturesÔºài.e., how ERC20 behavesÔºâ.

The `AMM contract` does not need to know which exact contract `tokenX` and `tokenY` are.
As long as the contracts implement the `ERC20` functions, we can interact with them via the interface.

To call a function from another contract, you can use the interface like so:

```solidity
tokenX.transfer()
```

[Reference article on interfaces](https://medium.com/coinmonks/solidity-tutorial-all-about-interfaces-f547d2869499)

---

üìì About Shares

Now let‚Äôs look at the state variables related to shares.

In this project, a share represents the proportion of tokens a liquidity provider has deposited into the pool.
It serves the same role as LP tokens commonly provided by DEXs.

To keep things simple, we will represent this as a numeric value stored in the contract.

> üìì What are LP Tokens?
> LP stands for Liquidity Provider tokens.
> They serve as proof of liquidity provided and can be used to reclaim the deposited assets and any earned rewards.

The share-related state variables are:

```solidity
uint256 public totalShare; // Total shares
mapping(address => uint256) public share; // Shares per user

uint256 public constant PRECISION = 1_000_000; // Precision for shares (= 6 digits)
```

`totalShare` represents the sum of all users‚Äô shares, and `share` keeps track of each user's individual share.

For example, to calculate the ratio of a user's deposited tokens (`addr`) to the total pool, use the following:

![](/images/AVAX-AMM/section-1/1_1_2.png)

This logic will be used when a liquidity provider withdraws tokens from the pool.

`PRECISION` handles decimals in share calculations, providing 6 digits of precision.
So a share of 1.23 will be stored as `1_230_000` internally.
This is similar to the relationship between `ether` and `wei` in Ethereum.

The value `1_000_000` is simply a more readable version of `1000000`.

---

Additionally, `totalAmount` is a mapping that stores the amount of each token that has been provided to the pool.

Finally, our `AMM contract` will determine the token pair for the pool at the time of deployment using a constructor,
so it accepts two contract addresses as arguments.

### üß™ Write Tests

Now that we‚Äôve implemented the contracts, let‚Äôs write a test.

Create a new file `AMM.ts` under the `test` directory and add the following code:

```ts
import { ethers } from "hardhat";
import { BigNumber } from "ethers";
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";

describe("AMM", function () {
  async function deployContract() {
    const [owner, otherAccount] = await ethers.getSigners();

    const amountForOther = ethers.utils.parseEther("5000");
    const USDCToken = await ethers.getContractFactory("USDCToken");
    const usdc = await USDCToken.deploy();
    await usdc.faucet(otherAccount.address, amountForOther);

    const JOEToken = await ethers.getContractFactory("JOEToken");
    const joe = await JOEToken.deploy();
    await joe.faucet(otherAccount.address, amountForOther);

    const AMM = await ethers.getContractFactory("AMM");
    const amm = await AMM.deploy(usdc.address, joe.address);

    return {
      amm,
      token0: usdc,
      token1: joe,
      owner,
      otherAccount,
    };
  }

  describe("init", function () {
    it("init", async function () {
      const { amm } = await loadFixture(deployContract);

      expect(await amm.totalShare()).to.eql(BigNumber.from(0));
    });
  });
});
```

This is a simple test to check the deployment process.

Inside the `deployContract` function, we deploy all three contracts in sequence.

During token contract deployment, we also mint tokens for both `owner` and `otherAccount` using the `faucet`.

When deploying the `AMM contract`, we pass in `USDCToken` and `JOEToken` to the constructor.

The following line checks the initial value of the `totalShare` variable in the deployed `AMM contract`.
‚Äª Return values from contracts are of type `BigNumber`.

```ts
expect(await amm.totalShare()).to.eql(BigNumber.from(0));
```

We will write more comprehensive tests in the next lesson.

üíÅ For more on testing with Hardhat, see [this guide](https://hardhat.org/hardhat-runner/docs/guides/test-contracts).

### ‚≠ê Run the Test

In the terminal, run:

```
yarn test
```

You should see output like this, indicating the test name and that it passed:

![](/images/AVAX-AMM/section-1/1_2_1.png)

### üôã‚Äç‚ôÇÔ∏è Ask Questions

If you‚Äôre confused or run into issues, ask in the `#avalanche` channel on Discord.

To make it easier for others to help you, please include the following in your error report ‚ú®

```
1. Section and lesson number your question relates to  
2. What you were trying to do  
3. Copy & paste the error message  
4. A screenshot of the error  
```

---

Now you‚Äôve learned how to create and test a contract üéâ
In the next lesson, we‚Äôll add more functionality to the smart contract.
