### ğŸ” å¯¾ç§°éµã®åŒæœŸæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã‚ˆã†

å¯¾ç§°éµã‚’åŒæœŸã™ã‚‹ãŸã‚ã«å¿…è¦ãªé–¢æ•°ã‚’ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«å®Ÿè£…ã—ã¾ã—ã‚‡ã†ã€‚

ã¾ãšã¯ã€å¯¾ç§°éµã‚’åŒæœŸã™ã‚‹ãŸã‚ã®æ‰‹é †ã‚’å†ç¢ºèªã—ã¦ãŠãã¾ã™ã€‚

1. å…¬é–‹éµã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
2. å¯¾ç§°éµã‚’ä¿æœ‰ã™ã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ãŒã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‹ã‚‰å…¬é–‹éµã‚’å–å¾—
3. å…¬é–‹éµã§å¯¾ç§°éµã‚’æš—å·åŒ–
4. æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
5. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‹ã‚‰æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’å–å¾—

ã“ã®ã†ã¡ã€ã€Œ1. å…¬é–‹éµã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã€ã¯æ—¢ã«å®Ÿè£…æ¸ˆã¿ã§ã™ï¼ˆregister_deviceé–¢æ•°ï¼‰ã€‚ã€Œ3. å…¬é–‹éµã§å¯¾ç§°éµã‚’æš—å·åŒ–ã€ã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å´ã§è¡Œã„ã¾ã™ã€‚

ã¾ãŸã€å¯¾ç§°éµã‚’åŒæœŸã™ã‚‹å‰ã«å¯¾ç§°éµã®ç”ŸæˆãŒå¿…è¦ã§ã™ãŒã€å¯¾ç§°éµã¯ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã”ã¨ã«1ã¤ã—ã‹ç”Ÿæˆã—ãªã„ãŸã‚ã€ç”Ÿæˆã®åˆ¤æ–­ææ–™ã¨ã—ã¦å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ã‚‚ã‚ã‚Šã¾ã™ã€‚ã‚ˆã£ã¦ã€ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã§å®Ÿè£…ã™ã‚‹é–¢æ•°ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

1. å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹é–¢æ•°
2. æœ€åˆã«å¯¾ç§°éµã‚’ä¿å­˜ã™ã‚‹é–¢æ•°
3. å…¬é–‹éµã‚’å–å¾—ã™ã‚‹é–¢æ•°
4. æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’ä¿å­˜ã™ã‚‹é–¢æ•°
5. æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’å–å¾—ã™ã‚‹é–¢æ•°

### ğŸ›  ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®å®Ÿè£…

ãã‚Œã§ã¯å®Ÿè£…ã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚devices.rså†…ã«å®šç¾©ã—ã¦ã„ã‚‹`delete_device`é–¢æ•°ã®ä¸‹ã«ã€ä¸‹è¨˜ã®é–¢æ•°ã‚’è¨˜è¿°ã—ã¾ã—ã‚‡ã†ã€‚

```rust
    /// æŒ‡å®šã—ãŸå…¬é–‹éµã«ç´ã¥ã„ã¦ã„ã‚‹å¯¾ç§°éµã‚’å–å¾—ã—ã¾ã™ã€‚
    ///
    /// # Returns
    /// * `Ok(EncryptedSymmetricKey)` - å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    /// * `DeviceError::UnknownPublicKey` - å…¬é–‹éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    /// * `DeviceError::KeyNotSynchronized` - å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    /// * `DeviceError::DeviceNotRegistered` - PrincipalãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    pub fn get_encrypted_symmetric_key(
        &mut self,
        caller: Principal,
        public_key: &PublicKey,
    ) -> SynchronizeKeyResult {
        match self.devices.get_mut(&caller) {
            Some(device_data) => {
                // å…¬é–‹éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚
                if !Self::is_registered_public_key(device_data, public_key) {
                    return Err(DeviceError::UnknownPublicKey);
                }
                match device_data.keys.get(public_key) {
                    // å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’è¿”ã—ã¾ã™ã€‚
                    Some(encrypted_symmetric_key) => Ok(encrypted_symmetric_key.clone()),
                    // å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
                    None => Err(DeviceError::KeyNotSynchronized),
                }
            }
            // ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
            None => Err(DeviceError::DeviceNotRegistered),
        }
    }

    /// å¯¾ç§°éµã‚’æŒã£ã¦ã„ãªã„å…¬é–‹éµã®ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚
    pub fn get_unsynced_public_keys(&mut self, caller: Principal) -> Vec<PublicKey> {
        match self.devices.get_mut(&caller) {
            // ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å…¬é–‹éµã®ã†ã¡ã€å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ã‚’ãƒ™ã‚¯ã‚¿ãƒ¼ã§è¿”ã—ã¾ã™ã€‚
            Some(device_data) => device_data
                .aliases
                .values()
                .filter(|public_key| !device_data.keys.contains_key(*public_key))
                .cloned()
                .collect(),
            None => Vec::new(),
        }
    }

    /// æŒ‡å®šã—ãŸPrincipalãŒå¯¾ç§°éµã‚’æŒã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®é–¢æ•°ã§ã™ã€‚
    /// ã“ã®é–¢æ•°ã¯ã€`register_encrypted_symmetric_key`ãŒå‘¼ã°ã‚Œã‚‹å‰ã«å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚
    ///
    /// # Returns
    /// * `true` - æ—¢ã«å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    /// * `false` - å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    pub fn is_encrypted_symmetric_key_registered(&self, caller: Principal) -> bool {
        self.devices
            .get(&caller)
            .map_or(false, |device_data| !device_data.keys.is_empty())
    }

    /// æŒ‡å®šã—ãŸPrincipalã®ãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã«ã€å¯¾ç§°éµã‚’ç™»éŒ²ã—ã¾ã™ã€‚
    /// ã“ã®é–¢æ•°ã¯ã€Principal1ã¤ã«ã¤ãã€ãŸã ä¸€åº¦ã ã‘å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚
    ///
    /// # Returns
    /// * `Ok(())` - ç™»éŒ²ã«æˆåŠŸã—ãŸå ´åˆ
    /// * `DeviceError::UnknownPublicKey` - å…¬é–‹éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    /// * `DeviceError::AlreadyRegistered` - æ—¢ã«å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    /// * `DeviceError::DeviceNotRegistered` - PrincipalãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    pub fn register_encrypted_symmetric_key(
        &mut self,
        caller: Principal,
        public_key: PublicKey,
        encrypted_symmetric_key: EncryptedSymmetricKey,
    ) -> RegisterKeyResult {
        match self.devices.get_mut(&caller) {
            Some(device_data) => {
                // ç™»éŒ²ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å…¬é–‹éµãŒã€ãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç™»éŒ²æ™‚ã«æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚
                if !Self::is_registered_public_key(device_data, &public_key) {
                    return Err(DeviceError::UnknownPublicKey);
                }
                // æ—¢ã«å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
                if !device_data.keys.is_empty() {
                    return Err(DeviceError::AlreadyRegistered);
                }
                device_data.keys.insert(public_key, encrypted_symmetric_key);
                Ok(())
            }
            // ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
            None => Err(DeviceError::DeviceNotRegistered),
        }
    }

    /// æŒ‡å®šã—ãŸPrincipalã®ãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã«ã€å…¬é–‹éµã¨å¯¾ç§°éµã®ãƒšã‚¢ã‚’ç™»éŒ²ã—ã¾ã™ã€‚
    ///
    /// # Returns
    /// * `Ok(())` - ç™»éŒ²ã«æˆåŠŸã—ãŸå ´åˆ
    /// * `DeviceError::UnknownPublicKey` - å…¬é–‹éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    /// * `DeviceError::DeviceNotRegistered` - PrincipalãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆ
    pub fn upload_encrypted_symmetric_keys(
        &mut self,
        caller: Principal,
        keys: Vec<(PublicKey, EncryptedSymmetricKey)>,
    ) -> RegisterKeyResult {
        match self.devices.get_mut(&caller) {
            Some(device_data) => {
                for (public_key, encrypted_symmetric_key) in keys {
                    if !Self::is_registered_public_key(device_data, &public_key) {
                        return Err(DeviceError::UnknownPublicKey);
                    }
                    device_data.keys.insert(public_key, encrypted_symmetric_key);
                }
                Ok(())
            }
            None => Err(DeviceError::DeviceNotRegistered),
        }
    }

    /// æŒ‡å®šã—ãŸãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã«ã€å…¬é–‹éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®é–¢æ•°ã§ã™ã€‚
    /// ã“ã®é–¢æ•°ã¯ã€å¼•æ•°ã«`PublicKey`ã‚’å—ã‘å–ã‚‹é–¢æ•°å†…ã§ä½¿ç”¨ã—ã¾ã™ã€‚
    fn is_registered_public_key(device_data: &DeviceData, public_key: &PublicKey) -> bool {
        device_data.aliases.values().any(|key| key == public_key)
    }
```

5ã¤ã®publicé–¢æ•°ã¨1ã¤ã®privateé–¢æ•°ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚å®šç¾©ã—ãŸé †åºã¨ã¯å‰å¾Œã—ã¾ã™ãŒã€å®Ÿéš›ã«å‘¼ã³å‡ºã™é †ç•ªã«ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

1\. å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹é–¢æ•°ï¼š`is_encrypted_symmetric_key_registered`é–¢æ•°

ã“ã®é–¢æ•°ã¯ã€DeviceDataæ§‹é€ ä½“ã®`keys`ãŒç©ºã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚`keys`ã¯HashMapãªã®ã§ã€ç©ºã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã«ã¯`is_empty`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

2\. æœ€åˆã«å¯¾ç§°éµã‚’ä¿å­˜ã™ã‚‹é–¢æ•°ï¼š`register_encrypted_symmetric_key`é–¢æ•°

ã“ã®é–¢æ•°ã¯ã€å¼•æ•°ã§å—ã‘å–ã£ãŸå…¬é–‹éµã¨æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’`keys`ã«ä¿å­˜ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ä¸Šè¨˜is_encrypted_symmetric_key_registeredé–¢æ•°ãŒfalseã‚’è¿”ã™å ´åˆã«ã®ã¿ãŸã ä¸€åº¦ã ã‘å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ï¼ˆ1ã¤ã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ãŒè¤‡æ•°ã®å¯¾ç§°éµã‚’ä¿å­˜ã—ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼‰ã€‚ãã®ãŸã‚ã€keysãŒç©ºã§ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚

```rust
                // æ—¢ã«å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
                if !device_data.keys.is_empty() {
                    return Err(DeviceError::AlreadyRegistered);
                }
```

3\. å…¬é–‹éµã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼š`get_unsynced_public_keys`é–¢æ•°

ã“ã®é–¢æ•°ã¯ã€ã¾ã æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã¨ä¸€ç·’ã«ä¿å­˜ã•ã‚Œã¦ã„ãªã„å…¬é–‹éµã‚’ãƒ™ã‚¯ã‚¿ãƒ¼ã§è¿”ã™é–¢æ•°ã§ã™ã€‚

4\. æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’ä¿å­˜ã™ã‚‹é–¢æ•°ï¼š`upload_encrypted_symmetric_keys`é–¢æ•°

ã“ã®é–¢æ•°ã¯ã€å¼•æ•°ã§å—ã‘å–ã£ãŸå…¬é–‹éµã¨æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’DeviceDataæ§‹é€ ä½“ã®keysã«ä¿å­˜ã—ã¾ã™ã€‚

5\. æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼š`get_encrypted_symmetric_key`é–¢æ•°

ã“ã®é–¢æ•°ã¯ã€å¼•æ•°ã§å—ã‘å–ã£ãŸå…¬é–‹éµã«å¯¾å¿œã™ã‚‹æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’è¿”ã—ã¾ã™ã€‚ã¾ã åŒæœŸå‡¦ç†ãŒè¡Œã‚ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚

```rust
                match device_data.keys.get(public_key) {
                    // å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æš—å·åŒ–ã•ã‚ŒãŸå¯¾ç§°éµã‚’è¿”ã—ã¾ã™ã€‚
                    Some(encrypted_symmetric_key) => Ok(encrypted_symmetric_key.clone()),
                    // å¯¾ç§°éµãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã—ã¾ã™ã€‚
                    None => Err(DeviceError::KeyNotSynchronized),
                }
```

`is_registered_public_key`é–¢æ•°ã¯ã€å¼•æ•°ã§å—ã‘å–ã£ãŸå…¬é–‹éµãŒãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç™»éŒ²æ™‚ã«æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹é–¢æ•°ã§ã™ã€‚å¼•æ•°ã«å…¬é–‹éµã‚’å—ã‘å–ã‚‹é–¢æ•°å†…ã§ä½¿ç”¨ã—ã¦ã€æœªçŸ¥ã®å…¬é–‹éµãŒæ‰±ã‚ã‚Œã¦ã—ã¾ã†ã“ã¨ã‚’é˜²ãã¾ã™ã€‚

```rust
    fn is_registered_public_key(device_data: &DeviceData, public_key: &PublicKey) -> bool {
        device_data.aliases.values().any(|key| key == public_key)
    }
```

ã§ã¯ã€è¿½åŠ ã—ãŸé–¢æ•°ã‚’lib.rsã‹ã‚‰å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚ä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’lib.rså†…ã®`fn delete_device(alias: DeviceAlias) {}`ã®ä¸‹ã«è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚

```rust
#[query(name = "getEncryptedSymmetricKey")]
fn get_encrypted_symmetric_key(public_key: PublicKey) -> SynchronizeKeyResult {
    let caller = caller();
    assert!(is_caller_registered(caller));

    DEVICES.with(|devices| {
        devices
            .borrow_mut()
            .get_encrypted_symmetric_key(caller, &public_key)
    })
}

#[query(name = "getUnsyncedPublicKeys")]
fn get_unsynced_public_keys() -> Vec<PublicKey> {
    let caller = caller();
    assert!(is_caller_registered(caller));

    DEVICES.with(|devices| devices.borrow_mut().get_unsynced_public_keys(caller))
}

#[query(name = "isEncryptedSymmetricKeyRegistered")]
fn is_encrypted_symmetric_key_registered() -> bool {
    let caller = caller();
    assert!(is_caller_registered(caller));

    DEVICES.with(|devices| {
        devices
            .borrow()
            .is_encrypted_symmetric_key_registered(caller)
    })
}

#[update(name = "registerEncryptedSymmetricKey")]
fn register_encrypted_symmetric_key(
    public_key: PublicKey,
    encrypted_symmetric_key: EncryptedSymmetricKey,
) -> RegisterKeyResult {
    let caller = caller();
    assert!(is_caller_registered(caller));

    DEVICES.with(|devices| {
        devices.borrow_mut().register_encrypted_symmetric_key(
            caller,
            public_key,
            encrypted_symmetric_key,
        )
    })
}

#[update(name = "uploadEncryptedSymmetricKeys")]
fn upload_encrypted_symmetric_keys(
    keys: Vec<(PublicKey, EncryptedSymmetricKey)>,
) -> RegisterKeyResult {
    let caller = caller();
    assert!(is_caller_registered(caller));

    DEVICES.with(|devices| {
        devices
            .borrow_mut()
            .upload_encrypted_symmetric_keys(caller, keys)
    })
}
```

### ğŸ¤ ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ›´æ–°ã—ã‚ˆã†

æ–°ã—ã„é–¢æ•°ã‚’å®šç¾©ã—ãŸã®ã§ã€`encrypted_notes_backend.did`ã‚’æ›´æ–°ã—ã¾ã—ã‚‡ã†ã€‚ä¸‹è¨˜ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
npm run generate:did
```

ãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢æ•°ã®å®šç¾©ãŒè¿½åŠ ã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚

### âœ… å‹•ä½œç¢ºèªã‚’ã—ã‚ˆã†

`test.sh`ã‚’æ›´æ–°ã—ã¾ã™ã€‚`# ===== ãƒ†ã‚¹ãƒˆ =====`ã®éƒ¨åˆ†ã‚’ä¸‹è¨˜ã®å†…å®¹ã§ä¸Šæ›¸ãã—ã¦ãã ã•ã„ã€‚

```
# ===== ãƒ†ã‚¹ãƒˆ =====
FUNCTION='registerDevice'
echo -e "\n===== $FUNCTION ====="
EXPECT='()'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_DEVICE_ALIAS_01\"', '\"$TEST_PUBLIC_KEY_01\"')'`
compare_result "Return none" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='getDeviceAliases'
echo -e "\n===== $FUNCTION ====="
EXPECT='(vec { '\"$TEST_DEVICE_ALIAS_01\"' })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Return device list" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='isEncryptedSymmetricKeyRegistered'
echo -e "\n===== $FUNCTION ====="
EXPECT='(false)'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Return false" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='registerEncryptedSymmetricKey'
echo -e "\n===== $FUNCTION ====="
EXPECT='(variant { Ok })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_PUBLIC_KEY_01\"', '\"$TEST_ENCRYPTED_SYMMETRIC_KEY_01\"')'`
compare_result "Return Ok" "$EXPECT" "$RESULT" || TEST_STATUS=1
# ç¢ºèª
FUNCTION='registerEncryptedSymmetricKey'
EXPECT='(variant { Err = variant { AlreadyRegistered } })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_PUBLIC_KEY_01\"', '\"$TEST_ENCRYPTED_SYMMETRIC_KEY_01\"')'`
compare_result "Return Err(AlreadyRegistered)" "$EXPECT" "$RESULT" || TEST_STATUS=1
# ç¢ºèª
FUNCTION='isEncryptedSymmetricKeyRegistered'
EXPECT='(true)'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Check with $FUNCTION" "$EXPECT" "$RESULT" || TEST_STATUS=1

# éµã®åŒæœŸå‡¦ç†
## åˆ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’ç™»éŒ²ã™ã‚‹
echo -e "\n===== Register other device & check unsynced ====="
UNUSED_RESULR=`dfx canister call encrypted_notes_backend registerDevice '('\"$TEST_DEVICE_ALIAS_02\"', '\"$TEST_PUBLIC_KEY_02\"')'`
FUNCTION='getEncryptedSymmetricKey'
EXPECT='(variant { Err = variant { KeyNotSynchronized } })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_PUBLIC_KEY_02\"')'`
compare_result "Return Err(KeyNotSynchronized)" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='getUnsyncedPublicKeys'
echo -e "\n===== $FUNCTION ====="
EXPECT='(vec { '\"$TEST_PUBLIC_KEY_02\"' })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Return unsynced public key list" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='uploadEncryptedSymmetricKeys'
echo -e "\n===== $FUNCTION ====="
EXPECT='(variant { Ok })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '(vec { record { '\"$TEST_PUBLIC_KEY_02\"'; '\"$TEST_ENCRYPTED_SYMMETRIC_KEY_02\"' } })'`
compare_result "Return Ok" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='getEncryptedSymmetricKey'
echo -e "\n===== $FUNCTION ====="
EXPECT='(variant { Ok = '\"$TEST_ENCRYPTED_SYMMETRIC_KEY_02\"' })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_PUBLIC_KEY_02\"')'`
compare_result "Return Ok" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='deleteDevice'
echo -e "\n===== $FUNCTION ====="
EXPECT='()'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '('\"$TEST_DEVICE_ALIAS_01\"')'`
compare_result "Return none" "$EXPECT" "$RESULT" || TEST_STATUS=1
# ç¢ºèª
FUNCTION='getDeviceAliases'
EXPECT='(vec { '\"$TEST_DEVICE_ALIAS_02\"' })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Check with $FUNCTION" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='addNote'
echo -e "\n===== $FUNCTION ====="
EXPECT='()'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '("First text!")'`
compare_result "Return none" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='getNotes'
echo -e "\n===== $FUNCTION ====="
EXPECT='(vec { record { id = 0 : nat; data = "First text!" } })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Return note list" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='updateNote'
echo -e "\n===== $FUNCTION ====="
EXPECT='()'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '(
  record {
    id = 0;
    data = "Updated first text!"
  }
)'`
compare_result "Return none" "$EXPECT" "$RESULT" || TEST_STATUS=1
# ç¢ºèª
FUNCTION='getNotes'
EXPECT='(vec { record { id = 0 : nat; data = "Updated first text!" } })'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Check with $FUNCTION" "$EXPECT" "$RESULT" || TEST_STATUS=1

FUNCTION='deleteNote'
echo -e "\n===== $FUNCTION ====="
EXPECT='()'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION '(0)'`
compare_result "Return none" "$EXPECT" "$RESULT" || TEST_STATUS=1
# ç¢ºèª
FUNCTION='getNotes'
EXPECT='(vec {})'
RESULT=`dfx canister call encrypted_notes_backend $FUNCTION`
compare_result "Check with $FUNCTION" "$EXPECT" "$RESULT" || TEST_STATUS=1
```

ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¦ã€`PASS`ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰ç¢ºèªã¯å®Œäº†ã§ã™ã€‚

ãŠç–²ã‚Œæ§˜ã§ã™ï¼ é•·ã‹ã£ãŸã§ã™ãŒã€ã“ã‚Œã§å¯¾ç§°éµã‚’åŒæœŸã™ã‚‹ãŸã‚ã®æº–å‚™ãŒã§ãã¾ã—ãŸã€‚æ¬¡ã¯ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã§å®Ÿéš›ã«å¯¾ç§°éµã®åŒæœŸå‡¦ç†ã‚’è¡Œãªã£ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

### ğŸ™‹â€â™‚ï¸ è³ªå•ã™ã‚‹

ã“ã“ã¾ã§ã®ä½œæ¥­ã§ä½•ã‹ã‚ã‹ã‚‰ãªã„ã“ã¨ãŒã‚ã‚‹å ´åˆã¯ã€Discordã®`#icp`ã§è³ªå•ã‚’ã—ã¦ãã ã•ã„ã€‚

ãƒ˜ãƒ«ãƒ—ã‚’ã™ã‚‹ã¨ãã®ãƒ•ãƒ­ãƒ¼ãŒå††æ»‘ã«ãªã‚‹ã®ã§ã€ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒãƒ¼ãƒˆã«ã¯ä¸‹è¨˜ã®4ç‚¹ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ âœ¨

```
1. è³ªå•ãŒé–¢é€£ã—ã¦ã„ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç•ªå·ã¨ãƒ¬ãƒƒã‚¹ãƒ³ç•ªå·
2. ä½•ã‚’ã—ã‚ˆã†ã¨ã—ã¦ã„ãŸã‹
3. ã‚¨ãƒ©ãƒ¼æ–‡ã‚’ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆ
4. ã‚¨ãƒ©ãƒ¼ç”»é¢ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
```

---

æ¬¡ã®ãƒ¬ãƒƒã‚¹ãƒ³ã«é€²ã¿ã€å¯¾ç§°éµã‚’ç”Ÿæˆã—ã¾ã—ã‚‡ã†ï¼
